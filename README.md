# Проектная работа 3 спринта. Часть 1
## Задание 1. Анализ и планирование

Проанализирована текущая архитектура монолитного приложения в контексте её готовности к целевой картине. Вот основные тезисы, возникшие в результате анализа:

1. **Монолитная архитектура ограничивает возможности масштабирования.**
   
   Если для поддержки работы небольшой компании с небольшим количеством клиентов монолитная архитектура вполне подходит, то учитывая предстоящие нагрузки, дальнейшее развитие в текущем виде она на выдержит. Хоть масштабирование и возможно, оно будет неэффективно и приведёт к излишним затратам на оборудование и поддержку, и в конце концов имеет предел.

2. **Ориентация на синхронное взаимодействие**

    Полностью синхронная архитектура приводит к тому, что система вынуждена ждать ответа на каждый запрос, прежде чем перейти к следующей задаче. Это замедляет обработку, особенно если устройство или база данных отвечает с задержкой. В условиях большого количества подключенных устройств синхронное взаимодействие может стать узким местом, ограничивая пропускную способность и надёжность системы. 

3. **Неподходящий способ коммуникации между системой и устройствами**

    Текущая схема взаимодействия, в которой сервер инициирует запросы к устройствам, создает значительную нагрузку на систему и не обеспечивает своевременную реакцию на изменение состояния устройства. Такой способ будет трудно масштабировать на сотни тысяч подключенных устройств.

4. **Используемая база данных не подходит для всех сценариев использования**

    Текущая реляционная база данных (PostgreSQL) хорошо подходит для определенных задач, но она не оптимальна для работы с большими объемами временных данных, такими как телеметрия.

5. **Отсутствие возможности самостоятельного подключения к системе**

    На текущий момент пользователи не могут самостоятельно подключить свои устройства, что создает лишнюю зависимость от выездных специалистов и делает масштабирование системы трудоемким. С увеличением количества домов и устройств в поселках, масштабирование процесса установки становится невозможно.

Составлена контекстная диаграмма: [monolith_context.puml](diagrams/monolith/context/monolith_context.puml)

![Context diagram](/diagrams/monolith/context/context_diagram.png)


## Задание 2. Проектирование микросервисной архитектуры

Исходя из выявленных в ходе анализа проблем, была разработана новая архитектура приложения в микросервисном стиле. Вот как с помощью неё будут решены вышеназванные проблемы:

1. **Микросервисная архитектура имеет гибкие возможности масштабирования.**
   
   Переход на микросервисную архитектуру позволил бы выделить отдельные сервисы, которые можно масштабировать независимо друг от друга. Кроме технического масштабирования, это позволит масштабировать команды разработки

2. **Ориентация на асинхронное взаимодействие**

    Использование асинхронного взаимодействия через очереди и брокеры позволит системе обрабатывать запросы и события параллельно, что значительно повысит её производительность и отзывчивость. Вместо того чтобы блокировать выполнение на каждом запросе, система сможет продолжать работать и обрабатывать другие операции, пока ожидает ответ от устройств или внешних сервисов. Это создаст более гибкую и масштабируемую архитектуру, способную справляться с высоким трафиком данных от множества подключенных устройств. 

3. **Использовавание протокола MQTT для взаимодействия системы с IoT-устройствами**

    Более предпочтительным способом взаимодействия в IoT-устройствами на данный момент является использование протокола MQTT. Протокол MQTT (Message Queuing Telemetry Transport) предназначен для обмена сообщениями в сетях с ограниченными ресурсами, таких как IoT-устройства. Он требует меньшего по сравненнию с HTTP объема трафика, ресурсов на передачу данных, что ведёт к экономии энергопотребления.  

4. **Использование специализированных баз данных для определенных сценариев работы**

    Постоянный поток данных от сотен и тысяч устройств требует специализированной базы данных для временных рядов, например, InfluxDB или ClickHouse, которые поддерживают высокую скорость записи и оптимизированы для анализа временных данных. Это позволило бы хранить телеметрию эффективно и выполнять запросы по временным рядам 

5. **Простота подключения устройств**

    Использование принятых в индустрии стандартных протоколов и способов подключения устройств позволит выполнять эти действия пользователям самостоятельно и позволит подключать к системе шировкий круг устройств.

Для реализации этих возможностей была спроектирована микросервисная архитектура, отражённая на схеме: [microservices_container.puml](diagrams/microservices/container/microservices_container.puml)

На схеме отражены только необходимые для понимания работы системы взаимодействия между сервисами. Некоторые из не указанных на схеме взаимодействий описаны ниже в описании сервисов.

![Container diagram](/diagrams/microservices/container/container_diagram.png)

Компонентная диаграмма сервиса управления сценариями: [scenarios_component_diagram.puml](diagrams/microservices/component/scenarios_component_diagram.puml)

На ней можно увидеть, что синхронизация кеша с основной базой данных происходит с помощью паттерна `Transactional Outbox`

![Component diagram](/diagrams/microservices/component/scenarios_component.png)

Диаграмма кода для сервиса управления сценариями (некоторой его части): [scenarios_code_diagram.puml](diagrams/microservices/code/scenarios_code_diagram.puml)

![Code diagram](/diagrams/microservices/code/scenarios_code.png)

### Описание предлагаемой архитектуры

Если охарактеризовать кратко, то предлагаемая архитектура опирается на взаимодействие с IoT-устройствами через протокол MQTT и потоковую обработку событий внутри системы с помощью брокера событий. Взаимодействие микросервисов преимущественно асихнронное, но с использованием синхронных вызовов где это необходимо или предпочтительнее.

Были выделены следующие ограниченные контексты:
- Авторизация и аутентификация
- Управление телеметрией
- Управление устройствами
- Управление сценариями
- Управление пользователями
- Управление Локациями

Все сервисы по умолчанию публикуют entity-events при изменении состояния сущностей. Это позволит другим сервисам синхронизировать необходимые данные в асинхронном режиме. Например:
- При отвязывании устройства от учетной записи пользователя, сервис сценариев ловит событие и деактивирует сценарии, в котором используется это устройство
- При отвязывании устройства от учетной записи пользователя, сервис телеметрии удаляет всю телеметрию по этому устройству 
- При регистрации пользователя в IAM, сервис "Управления пользователями" ловит событие и создаёт запись для пользователя у себя в БД
- При регистрации пользователя в IAM, сервис "Управления телеметрией" ловит событие и создаёт запись для пользователя у себя в БД
- При регистрации устройства, сервис телеметрии синхронизирует список устройств, копируя лишь некоторые необходимые поля (например, название и вендора)

Данный подход поможет впоследствии поддержать дополнительные сценарии интеграции, если в них возникнет необходимость. Например (описаны гипотетические сценарии с функциональностью, которая не описана в данном документе):
- При изменении уровня подписки клиента, сервис телеметрии обновляет уровень клиента у себя в БД и применяет TTL для хранения телеметрии не 90 дней, а 360
- Сервис уведомлений подписан на различные топики, формируя для пользователя журнал событий, который он может увидеть в приложении

#### Расчёты нагрузки
Рассчитаем ключевые показатели нагрузки.

Количество домов: 100 посёлков × 200 домов = **20_000 домов.**

Количество устройств: 20_000 × 5 = **100_000 устройств**

#### Оценка объёма запросов из клиентского приложения

Предположим, что средний клиент в среднем сделает 300 запросов в день. Какие-то пользователи могут использовать приложение очень активно, в то время как другие могут не заходить в него вовсе несколько дней. Можно предположить, что приложение будет использоваться в основном в дневные часы. Также, нужно учесть что пользователи приложения будут находится в разных часовых поясах. Предположим, что основная масса запросов будет происходить в рамках 20 часов.
> 20_000 пользователей * 300 / 20 / 3600 ~ **85 RPS**. Можно предположить, что будут пики до **150 RPS**

Допустим, каждый ответ от сервера в среднем составляет 100 КБ (килобайт):
> 100 КБ = 100 × 1024 × 8 = 819_200 бит
> 150 × 819_200 = 122_880_000 бит/с = **122.88 Мбит/с**

Таким образом, аренда гигабитного канала обеспечит рост количества пользователей как минимум в несколько раз.

#### Оценка объема телеметрии и ширины необходимого канала

Отправка телеметрии для каждого типа устройства
- Реле отопления: 1 сообщение каждые 15 минут (4 сообщения в час).
- Датчик температуры (2 шт): 1 сообщение каждые 5 минут (12 сообщений в час) на каждый датчик.
- Реле дверей гаража: 1 сообщение каждые 15 минут (4 сообщения в час).
- Реле включения света: 1 сообщение каждые 15 минут (4 сообщения в час).

Для одного дома телеметрия составит:

> (1 × 4) + (2 × 12) + (1 × 4) + (1 × 4) = 4 + 24 + 4 + 4 = **36 сообщений в час**

Для всех 20,000 домов это будет:

> 36 × 20_000 = **720_000 сообщений в час** или 720_000/3600 ≈ **200 сообщений в секунду**

Предположим, что каждое сообщение составляет 100 байт (включая данные и заголовок). Ежедневный объём данных:

> 720_000 сообщений × 24 × 100 байт = 1_728_000_000 байт ≈ **1.7 ГБ в день**

Для хранения данных с TTL в 3 месяца (около 90 дней): 
> 1.7 ГБ × 90 ≈ **153ГБ**

Средний трафик к MQTT брокеру в секунду: 
> 200 сообщений × 100 байт = 20_000 байт/сек = **20 КБ/сек**

Таким образом, можно констатировать, что предполагаемым объемом данных телеметрии с точки зрения ширина канала можно пренебречь, даже если увеличить количество устройств или частоту отправки телеметрии.

#### Оценка количества событий в Kafka

Команды от пользователей: 20,000 пользователей, в среднем по 50 команд в день (1_000_000 команд в день). Предположим, что сценарии автоматизации будут генерировать похожее количество команд. Вместе это примерно 25 событий в секунду.
> 25 команд в секунду + 200 событий телеметрии в секунду = **225 событий в секунду**

#### Оценка количества сценариев и активных условий

Предположим, что каждый пользователь создаст 15 сценариев.
> 15 * 20_000 домов = 300_000 сценариев

Размер одного сценария должен с запасом поместится в 5 КБ. С учётом предположений, объём данных составит:
> 300_000 сценариев × 5 КБ = 1_200_000 КБ = **1,2 ГБ**


#### Web Application
Разработка клиентского приложения передана на аутсорс и не входит в рамки этого задания, однако стоит сказать, что оно должно предоставлять возможности самостоятельного подключения клиентских устройств. Подразумевается, что это веб-приложение, но предпочтительнее, если бы это было мобильное приложение, которое может использовать Bluetooth, Wi-Fi или NFC для обнаружения и подключения новых устройств. Также, мобильное приложение удобнее для управления умным домом, чем веб-приложение.

#### Identity and Access Management

Единая точка аутентификации и авторизация. Так как домен является универсальным, то было принято решение использовать стороннее ПО для реализации. В частности, был выбран KeyCloak как предоставляющий весь необходимый набор функций.

#### API Gateway

Служит единой точкой доступа к API системы, выполняет авторизацию запросов, записывает метрики и логи.

#### MQTT Broker

Брокер для взаимодействия с IoT-устройствами, через который устройства отправляют телеметрию и получают команды. Работает на лёгком и эффективном протоколе MQTT, обеспечивая минимальные задержки и низкое энергопотребление.

#### Kafka

Система обмена сообщениями, служащая шиной данных для микросервисов. В Kafka передаются телеметрия и события от IoT-устройств для обработки и передачи другим сервисам. Kafka поддерживает горизонтальное масштабирование и может обрабатывать большой объём сообщений от десяткой тысяч устройств.

#### Kafka Connect

Инструмент для интеграции Kafka с внешними системами. Используется для ретрансляции данных из MQTT Broker в Kafka и обратно. Позволяет настраивать потоки данных без написания кода, подключая Kafka к различным базам данных, хранилищам и брокерам сообщений.

#### Telemetry service

Сервис для обработки и хранения телеметрии, получаемой от IoT-устройств. Подписывается на сообщения в Kafka, записывает телеметрию в базу данных для последующего анализа и извлечения данных. Использует ClickHouse для хранения данных о телеметрии, что позволяет эффективно обрабатывать временные ряды. Предоставляет REST API для получения телеметрии по конкретному устройству.

#### Devices service

Сервис для управления IoT-устройствами и их состоянием. Хранит информацию об устройствах, обрабатывает команды для включения или выключения устройств. Также подписывается на Kafka для обновления состояния устройств на основе событий и команд. Предоставляет REST API для получения информации по состоянию устройств и отправки команд для этих устройств. Команды публикуются в Kafka и через Kafka Connect и MQTT брокер доставляются до устройства.

#### Scenarios service

Сервис для создания и выполнения сценариев автоматизации. Хранит пользовательские сценарии, например, автоматическое включение кондиционера при высокой температуре. Обрабатывает события из Kafka, проверяя условия выполнения сценариев и, при необходимости, отправляет команды другим устройствам через Devices Service. Для максимальной пропускной способности при обработке потока телеметрии, условия из сценариев закешированы в in-memory кеше (Redis). При срабатывании определенного условия весь сценарий получается из основной базы данных для определения дальнейших действий. Учитывая предполагаемый объем всех сценариев в 1.2 ГБ, то хранение одних лишь условий в Redis потребует не более **200 МБ**. Вполне допустимо решение хранить все сценарии полностью в Redis, используя основную базу данных лишь для восстановления кеша в случае его утраты.
Взаимодействует с `Devices service` для отправки команд на устройства.

#### Users service

Сервис для управления пользователями и их данными, включая профиль, настройки и предпочтения. Прослушивает события из Kafka от Keycloak для для создания записей о пользователях в собственной базе данных. Также, сервис позволяет устанавливать уровень подписки пользователя, от которого могут зависеть некоторые параметры, например, максимальное время хранения телеметрии или максимально возможное количество устройств.

#### Locations service

Сервис для управления локациями и зонами. Позволяет пользователям создавать локации и помещения (зоны), к которым будут привязаны устройства. Обеспечивает организацию и структуру для управления устройствами в рамках умных домов и посёлков. В дальнейшем возможно активное развитие данного сервиса. Например, может появиться возможность использовать географические координаты, чтобы определять время рассвета\заката для сценариев автоматизации. Также, может появиться возможность составлять план помещения с размещением датчиков, что позволит, например, управлять устройствами на карте дома через сенсорный экран одним нажатием.

## Задание 3. Разработка ER-диаграммы

Основные сущности системы:

- Телеметрия: [er-telemetry.puml](diagrams/microservices/er/er-telemetry.puml)

![](/diagrams/microservices/er/er-telemetry.png)

- Пользователь: [er-user.puml](diagrams/microservices/er/er-user.puml)

![](/diagrams/microservices/er/er-user.png)

- Сценарий: [er-scenario.puml](diagrams/microservices/er/er-scenario.puml)

![](/diagrams/microservices/er/er-scenario.png)

- Локация: [er-location.puml](diagrams/microservices/er/er-location.puml)

![](/diagrams/microservices/er/er-location.png)

- Устройство: [er-device.puml](diagrams/microservices/er/er-device.puml)

![](/diagrams/microservices/er/er-device.png)

В данных диаграммах хорошо можно проследить принцип, согласно которому микросервисы через шину событий синхронизируют необходимые для работы данные сущностей из других сервисов. Таким образом, сервис остаётся максимально автономным без необходимости лишний раз образаться за данным в другие сервисы. Например, в сервисе пользователей можно настроить уровни подписки, от которых зависит несколько параметров:
- Длительность хранения телеметрии
- Максимальное количество устройств
- Максимальное количество локаций
- Максимальное количество сценариев

Микросервисы синхронизируют только необходимую информацию, чтобы избежать лишнего количества запросов в сервис пользователей.

# Проектирование API
Для просмотра спецификации OPEN API сервиса "Сценариев" откройте [open-api.json](./open-api.json)
Для просмотра спецификации ASYNC API сервиса "Устройств" откройте [async-api.yml](./async-api.yml)

Или используйте [Swagger UI](https://swagger.io/tools/swagger-ui/) для удобного просмотра документации.